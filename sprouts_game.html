<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprouts: Euler KarakteristiÄŸi Oyunu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 0;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 900px;
            width: 100%;
        }

        /* Navigation Tabs */
        .nav-tabs {
            display: flex;
            background: #f5f5f5;
            border-radius: 15px 15px 0 0;
            overflow: hidden;
            border-bottom: 3px solid #667eea;
        }

        .nav-tab {
            flex: 1;
            padding: 18px 20px;
            text-align: center;
            cursor: pointer;
            background: #f5f5f5;
            border: none;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
            border-right: 1px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .nav-tab:last-child {
            border-right: none;
        }

        .nav-tab:hover {
            background: #e8e8e8;
        }

        .nav-tab.active {
            background: white;
            color: #667eea;
            border-bottom: 3px solid #667eea;
            margin-bottom: -3px;
        }

        .tab-content {
            display: none;
            padding: 20px;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Game Tab */
        h1 {
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        #canvas {
            border: 3px solid #333;
            border-radius: 10px;
            cursor: crosshair;
            display: block;
            background: white;
            margin: 0 auto;
        }

        .controls {
            margin: 15px 0;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: #667eea;
            color: white;
            transition: all 0.3s;
            font-weight: bold;
        }

        button:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .status {
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            color: #333;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 8px;
            margin-top: 10px;
        }

        /* Topology Tab */
        .topology-content {
            max-width: 800px;
            margin: 0 auto;
        }

        .topology-content h2 {
            color: #667eea;
            margin: 25px 0 15px 0;
            font-size: 24px;
        }

        .topology-content h3 {
            color: #764ba2;
            margin: 20px 0 10px 0;
            font-size: 20px;
        }

        .topology-content p {
            color: #555;
            line-height: 1.8;
            margin-bottom: 15px;
            text-align: justify;
        }

        .topology-content ul {
            margin-left: 25px;
            margin-bottom: 15px;
        }

        .topology-content li {
            color: #555;
            line-height: 1.8;
            margin-bottom: 8px;
        }

        .formula {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            color: #667eea;
            margin: 20px 0;
        }

        .example-box {
            background: #f9f9f9;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 400px;
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: #333;
        }

        .modal-content p {
            margin: 10px 0;
            font-size: 18px;
        }

        .modal-content input {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: 2px solid #667eea;
            border-radius: 8px;
            margin: 15px 0;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .nav-tab {
                font-size: 14px;
                padding: 15px 10px;
            }
            
            #canvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Navigation Tabs -->
        <div class="nav-tabs">
            <button class="nav-tab active" onclick="switchTab('game')">
                ğŸ® Oyun
            </button>
            <button class="nav-tab" onclick="switchTab('topology')">
                ğŸ“ Topolojik Ã–zellikler
            </button>
            <button class="nav-tab" onclick="window.location.href='index.html'">
                ğŸ  Anasayfa
            </button>
        </div>

        <!-- Game Tab -->
        <div id="gameTab" class="tab-content active">
            <h1>ğŸŒ± Sprouts: Euler KarakteristiÄŸi Oyunu</h1>
            
            <div class="controls">
                <button onclick="game.newGame()">ğŸ® Yeni Oyun</button>
                <button onclick="game.showEuler()">ğŸ“Š Euler KarakteristiÄŸi</button>
            </div>

            <div class="status" id="status">Oyuncu 1'in sÄ±rasÄ±</div>

            <canvas id="canvas" width="800" height="600"></canvas>
        </div>

        <!-- Topology Tab -->
        <div id="topologyTab" class="tab-content">
            <div class="topology-content">
                <h1>ğŸ“ Sprouts Oyununun Topolojik Ã–zellikleri</h1>

                <h2>ğŸ¯ Oyun HakkÄ±nda</h2>
                <p>
                    Sprouts, 1967 yÄ±lÄ±nda Cambridge Ãœniversitesi'nde John Horton Conway ve Michael S. Paterson 
                    tarafÄ±ndan icat edilmiÅŸ bir kaÄŸÄ±t-kalem oyunudur. Oyun, graf teorisi ve topoloji ile 
                    yakÄ±ndan iliÅŸkilidir ve matematiksel aÃ§Ä±dan son derece zengin bir yapÄ±ya sahiptir.
                </p>

                <h2>ğŸ“Š Euler KarakteristiÄŸi</h2>
                <p>
                    Euler karakteristiÄŸi, topolojik bir uzayÄ±n temel Ã¶zelliklerinden biridir. Bir graf veya 
                    Ã§okyÃ¼zlÃ¼ iÃ§in Euler karakteristiÄŸi ÅŸu formÃ¼lle hesaplanÄ±r:
                </p>
                <div class="formula">
                    Ï‡ = V - E + F
                </div>
                <p>Burada:</p>
                <ul>
                    <li><strong>V (Vertices):</strong> KÃ¶ÅŸe (nokta) sayÄ±sÄ±</li>
                    <li><strong>E (Edges):</strong> Kenar (Ã§izgi) sayÄ±sÄ±</li>
                    <li><strong>F (Faces):</strong> YÃ¼z (bÃ¶lge) sayÄ±sÄ±</li>
                    <li><strong>Ï‡ (Chi):</strong> Euler karakteristiÄŸi</li>
                </ul>

                <h3>DÃ¼zlemsel Graflar Ä°Ã§in</h3>
                <p>
                    Sprouts oyunu dÃ¼zlemsel bir graf oluÅŸturur (kenarlar kesiÅŸmez). BaÄŸlantÄ±lÄ± bir dÃ¼zlemsel 
                    graf iÃ§in Euler karakteristiÄŸi her zaman <strong>Ï‡ = 2</strong>'dir. Bu, topolojinin en 
                    temel teoremlerinden biridir.
                </p>

                <div class="example-box">
                    <strong>Ã–rnek:</strong> 3 nokta ile baÅŸlayan bir Sprouts oyununda:
                    <ul>
                        <li>BaÅŸlangÄ±Ã§: V = 3, E = 0, F = 1 â†’ Ï‡ = 3 - 0 + 1 = 4</li>
                        <li>Ä°lk hamle sonrasÄ±: V = 4, E = 2, F = 2 â†’ Ï‡ = 4 - 2 + 2 = 4</li>
                    </ul>
                    <em>Not: Sprouts'ta F hesabÄ± Ã¶zel kurallar gerektirir.</em>
                </div>

                <h2>ğŸ² Oyun KurallarÄ±</h2>
                <ul>
                    <li>Oyun n adet noktayla baÅŸlar</li>
                    <li>Her hamle, iki nokta arasÄ±na bir eÄŸri Ã§izerek yapÄ±lÄ±r</li>
                    <li>Ã‡izilen eÄŸrinin ortasÄ±na yeni bir nokta eklenir</li>
                    <li>Her noktadan en fazla 3 Ã§izgi Ã§Ä±kabilir</li>
                    <li>EÄŸriler kendini veya baÅŸka eÄŸrileri kesemez</li>
                    <li>Hamle yapamayan oyuncu kaybeder</li>
                </ul>

                <h2>ğŸ”¢ Matematiksel Ã–zellikler</h2>
                
                <h3>Hamle SayÄ±sÄ±</h3>
                <p>
                    n noktayla baÅŸlayan bir Sprouts oyunu en az <strong>2n</strong> ve en fazla 
                    <strong>3n - 1</strong> hamle sÃ¼rer. Bu sÄ±nÄ±rlar, her noktanÄ±n maksimum 3 baÄŸlantÄ±ya 
                    sahip olabileceÄŸi kuralÄ±ndan kaynaklanÄ±r.
                </p>

                <h3>Kazanan Strateji</h3>
                <p>
                    Sprouts oyununun kazanan stratejisi, baÅŸlangÄ±Ã§ nokta sayÄ±sÄ±na baÄŸlÄ±dÄ±r:
                </p>
                <ul>
                    <li>n = 1, 2, 4, 5: Ä°lk oyuncu kazanÄ±r</li>
                    <li>n = 0, 3, 6: Ä°kinci oyuncu kazanÄ±r</li>
                    <li>Daha bÃ¼yÃ¼k n deÄŸerleri iÃ§in strateji daha karmaÅŸÄ±ktÄ±r</li>
                </ul>

                <h2>ğŸŒ Topolojik BaÄŸlantÄ±lar</h2>
                
                <h3>Graf Teorisi</h3>
                <p>
                    Sprouts oyunu, planar (dÃ¼zlemsel) graf teorisinin mÃ¼kemmel bir Ã¶rneÄŸidir. Oyun sÄ±rasÄ±nda 
                    oluÅŸan yapÄ±, her zaman dÃ¼zlemde Ã§izilebilir bir graftÄ±r.
                </p>

                <h3>Homeomorfizm</h3>
                <p>
                    Ä°ki Sprouts konfigÃ¼rasyonu, eÄŸer biri sÃ¼rekli deformasyonlarla diÄŸerine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lebiliyorsa 
                    topolojik olarak eÅŸdeÄŸerdir. Bu, oyunun stratejisini anlamak iÃ§in Ã¶nemlidir.
                </p>

                <h3>DÃ¼ÄŸÃ¼m Teorisi</h3>
                <p>
                    Sprouts'ta Ã§izilen eÄŸriler, dÃ¼ÄŸÃ¼m teorisi aÃ§Ä±sÄ±ndan da incelenebilir. Ancak oyun kurallarÄ± 
                    gereÄŸi karmaÅŸÄ±k dÃ¼ÄŸÃ¼mler oluÅŸmaz.
                </p>

                <div class="example-box">
                    <strong>Ä°lginÃ§ GerÃ§ek:</strong> Sprouts oyunu, bilgisayar biliminde NP-hard 
                    problemlerle iliÅŸkilendirilmiÅŸtir. Bir pozisyonun kazanan mÄ± yoksa kaybeden mi 
                    olduÄŸunu belirlemek, hesaplama aÃ§Ä±sÄ±ndan zordur.
                </div>

                <h2>ğŸ“š Kaynaklar ve Ä°leri Okuma</h2>
                <ul>
                    <li>Conway, J. H. (1976). "On Numbers and Games"</li>
                    <li>Gardner, M. (1967). "Mathematical Games" - Scientific American</li>
                    <li>Applegate, D., Jacobson, G., & Sleator, D. (1991). "Computer Analysis of Sprouts"</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Modal -->
    <div class="modal" id="modal">
        <div class="modal-content">
            <h2 id="modalTitle">BaÅŸlangÄ±Ã§ NoktalarÄ±</h2>
            <p id="modalText">KaÃ§ nokta ile baÅŸlamak istersiniz?</p>
            <input type="number" id="modalInput" min="2" max="15" value="2">
            <div class="modal-buttons">
                <button onclick="game.handleModalOK()">Tamam</button>
                <button onclick="game.handleModalCancel()">Ä°ptal</button>
            </div>
        </div>
    </div>

    <script>
        // Tab Switching Function
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab
            if (tabName === 'game') {
                document.getElementById('gameTab').classList.add('active');
                document.querySelectorAll('.nav-tab')[0].classList.add('active');
            } else if (tabName === 'topology') {
                document.getElementById('topologyTab').classList.add('active');
                document.querySelectorAll('.nav-tab')[1].classList.add('active');
            }
        }

        class SproutsGame {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.statusLabel = document.getElementById('status');
                
                this.vertices = [];
                this.edges = [];
                this.currentPlayer = 1;
                this.drawing = false;
                this.startVertex = null;
                this.MAX_CONNECTIONS = 3;
                this.controlPoint = null;
                this.tempLine = null;
                
                this.MIN_WIDTH = 800;
                this.MIN_HEIGHT = 600;
                
                this.setupEvents();
                this.promptNewGame();
            }

            setupEvents() {
                this.canvas.addEventListener('mousedown', (e) => this.canvasClick(e));
                this.canvas.addEventListener('mousemove', (e) => this.canvasDrag(e));
                this.canvas.addEventListener('mouseup', (e) => this.canvasRelease(e));
            }

            promptNewGame() {
                const modal = document.getElementById('modal');
                document.getElementById('modalTitle').textContent = 'BaÅŸlangÄ±Ã§ NoktalarÄ±';
                document.getElementById('modalText').textContent = 'KaÃ§ nokta ile baÅŸlamak istersiniz?';
                document.getElementById('modalInput').value = '2';
                modal.style.display = 'flex';
            }

            handleModalOK() {
                const numPoints = parseInt(document.getElementById('modalInput').value) || 2;
                document.getElementById('modal').style.display = 'none';
                this.startNewGame(numPoints);
            }

            handleModalCancel() {
                document.getElementById('modal').style.display = 'none';
                if (this.vertices.length === 0) {
                    this.startNewGame(2);
                }
            }

            newGame() {
                this.promptNewGame();
            }

            startNewGame(numPoints) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.vertices = [];
                this.edges = [];
                this.currentPlayer = 1;
                this.drawing = false;
                this.startVertex = null;
                
                const width = this.canvas.width;
                const height = this.canvas.height;
                const radius = Math.min(width, height) * 0.35;
                const centerX = width / 2;
                const centerY = height / 2;
                
                for (let i = 0; i < numPoints; i++) {
                    const angle = 2 * Math.PI * i / numPoints;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    this.addVertex(x, y);
                }
                
                this.updateStatus();
            }

            addVertex(x, y) {
                const vertexId = this.vertices.length;
                this.vertices.push({x, y, connections: 0});
                this.drawVertex(x, y, vertexId);
            }

            drawVertex(x, y, vertexId) {
                const radius = 10;
                const vertex = this.vertices[vertexId];
                
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, 2 * Math.PI);
                this.ctx.fillStyle = vertex.connections < this.MAX_CONNECTIONS ? '#4ade80' : '#ef4444';
                this.ctx.fill();
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();
            }

            findClosestVertex(x, y) {
                let closestDist = Infinity;
                let closestVertex = null;
                
                for (let i = 0; i < this.vertices.length; i++) {
                    const v = this.vertices[i];
                    if (v.connections >= this.MAX_CONNECTIONS) continue;
                    
                    const dist = Math.sqrt((x - v.x) ** 2 + (y - v.y) ** 2);
                    if (dist < 30 && dist < closestDist) {
                        closestDist = dist;
                        closestVertex = i;
                    }
                }
                
                return closestVertex;
            }

            calculateControlPoints(startX, startY, endX, endY, offsetFactor = 0.3) {
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2;
                
                const dx = endX - startX;
                const dy = endY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const offset = distance * offsetFactor;
                const control1X = midX - dy * offset / distance;
                const control1Y = midY + dx * offset / distance;
                const control2X = midX + dy * offset / distance;
                const control2Y = midY - dx * offset / distance;
                
                return [{x: control1X, y: control1Y}, {x: control2X, y: control2Y}];
            }

            drawCurve(startX, startY, controlX, controlY, endX, endY, temp = false) {
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                this.ctx.strokeStyle = temp ? '#3b82f6' : '#000';
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
            }

            canvasClick(event) {
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const vertexId = this.findClosestVertex(x, y);
                
                if (vertexId !== null) {
                    this.drawing = true;
                    this.startVertex = vertexId;
                    this.controlPoint = null;
                }
            }

            canvasDrag(event) {
                if (!this.drawing || this.startVertex === null) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const start = this.vertices[this.startVertex];
                const controls = this.calculateControlPoints(start.x, start.y, x, y);
                this.controlPoint = controls[0];
                
                this.redraw();
                this.drawCurve(start.x, start.y, this.controlPoint.x, this.controlPoint.y, x, y, true);
            }

            canvasRelease(event) {
                if (!this.drawing) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const endVertex = this.findClosestVertex(x, y);
                
                if (endVertex !== null && endVertex !== this.startVertex) {
                    const start = this.vertices[this.startVertex];
                    const end = this.vertices[endVertex];
                    
                    const newX = (start.x + end.x) / 2;
                    const newY = (start.y + end.y) / 2;
                    
                    const controls = this.calculateControlPoints(start.x, start.y, end.x, end.y);
                    
                    this.drawCurve(start.x, start.y, controls[0].x, controls[0].y, newX, newY);
                    this.drawCurve(newX, newY, controls[1].x, controls[1].y, end.x, end.y);
                    
                    const newVertexId = this.vertices.length;
                    this.addVertex(newX, newY);
                    
                    this.edges.push({
                        startX: start.x, startY: start.y,
                        controlX: controls[0].x, controlY: controls[0].y,
                        endX: newX, endY: newY
                    });
                    this.edges.push({
                        startX: newX, startY: newY,
                        controlX: controls[1].x, controlY: controls[1].y,
                        endX: end.x, endY: end.y
                    });
                    
                    this.vertices[this.startVertex].connections++;
                    this.vertices[endVertex].connections++;
                    this.vertices[newVertexId].connections += 2;
                    
                    this.drawVertex(start.x, start.y, this.startVertex);
                    this.drawVertex(end.x, end.y, endVertex);
                    
                    this.currentPlayer = 3 - this.currentPlayer;
                    this.updateStatus();
                }
                
                this.drawing = false;
                this.startVertex = null;
                this.controlPoint = null;
                this.redraw();
            }

            redraw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                for (const edge of this.edges) {
                    this.drawCurve(edge.startX, edge.startY, edge.controlX, edge.controlY, edge.endX, edge.endY);
                }
                
                for (let i = 0; i < this.vertices.length; i++) {
                    const v = this.vertices[i];
                    this.drawVertex(v.x, v.y, i);
                }
            }

            updateStatus() {
                this.statusLabel.textContent = `Oyuncu ${this.currentPlayer}'in sÄ±rasÄ±`;
                
                const activeVertices = this.vertices.filter(v => v.connections < this.MAX_CONNECTIONS).length;
                if (activeVertices < 2 && this.vertices.length > 0) {
                    setTimeout(() => {
                        alert(`Oyun Bitti!\nOyuncu ${3 - this.currentPlayer} kazandÄ±!`);
                    }, 100);
                }
            }

            showEuler() {
                const V = this.vertices.length;
                const E = this.edges.length;
                const F = this.calculateFaces();
                const euler = V - E + F;
                
                const modal = document.getElementById('modal');
                document.getElementById('modalTitle').textContent = 'Euler KarakteristiÄŸi';
                document.getElementById('modalText').innerHTML = `
                    <strong>Vertices (V):</strong> ${V}<br>
                    <strong>Edges (E):</strong> ${E}<br>
                    <strong>Faces (F):</strong> ${F}<br>
                    <strong>V - E + F = ${euler}</strong>
                `;
                document.getElementById('modalInput').style.display = 'none';
                modal.style.display = 'flex';
                
                setTimeout(() => {
                    document.getElementById('modalInput').style.display = 'block';
                }, 100);
            }

            calculateFaces() {
                if (this.edges.length === 0) return 1;
                return Math.max(1, this.edges.length - this.vertices.length + 2);
            }
        }

        const game = new SproutsGame();
    </script>
</body>
</html>